//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			> OBJECT ORIENTED PROGRAMMING (OOP): A PARADIGM BASED IN THE CONCEPT OF OBJECTS	<
			
· OBJECTS MAY CONTAIN DATA, AND METHODS. WE PACK THE DATA AND IT'S CORRESPONDING BEHAVIOUR.
· OBJECTS ARE SELF-CONTAINED PIECES OF CODE.
· ARE BUILDING BLOCKS OF APPLICATIONS, AND INTERACT WITH ONE ANOTHER.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			> CLASSES <
	
· LIKE "BLUEPRINTS" FROM WHICH WE CAN CREATE NEW OBJECTS.
	!!! JAVASCRIPT DOES NOT SUPPORT REAL CLASSES. IT WORKS A BIT DIFFERENT.
	
	· INSTANCES : OBJECTS CREATED FROM A CLASS.
			WE CAN CREATE AS MANY INSTANCES AS WE NEED FROM OUR CLASSES.
			
· HOW TO DESIGN CLASSES:
    > ABSTRACTION : Ignoring or hiding detals that "don't matter", allowing us to get an overview perspective of the
    "thing" we're implementing, instead of messing with details that don't really matter to our implementation.
    
    > ENCAPSULATION : Keeping properties and methods private inside the class, so they are NOT accesible from outside 
    the class. Some methods can be exposed as public. (as a public interface - APi).
    	This prevents external code from accidetally manipulating internal properties/state.
    	Also allows to change internal implemetantion without the risk of breaking external code.
    	
    > INHERITANCE : In OOP when we have classes closely related to one another, we can have inherit his properties 
    from a "parent" class. Child class extends parent class.
    	Inherintance makes all properties and methods of a certain class available to a child class, formin a
    hierarchical relationship between classes. This allows us to reuse common logic and to model real-world relationships.
    
    > POLIMORPHISM : A child class can overwrite a method it inherited from a parent class (It's more complex thant that).
    
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			> OOP IN JAVASCRIPT <
			
· "CLASSICAL OOP" : WE HAVE CLASSES (LIKE BLUEPRINTS) AND WE CANT INSTATIATE AS MANY TIMES AS WE NEED.
	-> INSTATIATION : CREATING AN INSTANCE (OBJECT) FROM A CLASS.
	
· IN JAVASCRIPT WE HAVE PROTOTYPES
	> OBJECTS ARE LINKED TO A PROTOTYPE OBJECT.
	> The prototype contain methods that all objects linked to it can access and use.
									> THAS CALLED PROTOTYPAL INHERTANCE <!!!
									
· PROTOYPAL INHERITANCE: The prototype contains mehtods(behaviour) thar are accessible to all objects linked to that prototype.
			> !! THIS IS DIFFERENT FROM PARENT-CHILD CLASSES INHERITANCE.

· IN classical OOP, behaviour (METHODs) is COPIED from class to all  instances
· IN JAVASCRIPT behaviour is DELEGATED to the linked protoype object.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			> IMPLEMENTING PROTOTYPAL INHERITANCE <
	How to implement OOP in JS ? 
	There are 3 ways of doing it:

   (1) - CONSTRUCTOR FUNCTIONS : 
   	> Technique to create objects from a function.
   	> This is how built-in objects like Arrays, Maps, or Sets are actually implemented.
   	
   (2) - ES6 CLASSES : 
   	> Modern alternative to constructor function syntax.
   	> "Syntactic sugar". Behind the scenes, ES6 CLASES works exactly like constructor functions.
   	> ES6 classes do NOT behave like CLASSES in "CLASSICAL OOP".
   	
   (3) - OBJECT.CREATE() : 
	> The easiest and most straightforward way of linking an object to a protoype object.
	> It's not as used as the other 4 methods.
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			> CONSTRUCTOR FUNCTIONS AND NEW OPERATOR <
			
    > We can use a function to create objects (It's a completely normal function).
    > The only difference is that we call te function with the "new" operator.
		!: Convension : Constructor functions start with a capital letter.
	
    · When a constructor function with "new" keyword is called:
    	1 · A new {empty obj} is created.
    	2 · Function is called. This keyword points to the {}.
    	3 · {} is linked to the prototype (__proto__).
    	4 · function automatically return {}
    
    > We can set with the "this" keyword properties inside the function, then it's returned.
    
    > "Instances" : Even when the obj. are not created from a class, they're called instances.
    We can check wheter an object is an instance from it's constructor function with the "INSTANCEOF" method.
    Is used in lowercase, and without dot notation.
   	Eg: car instanceof Vehicles (car is the created object, and Vehicles is the constructor function).
   	
   	 >>>  SINTAX  <<< 
   
   //constructor function//
const Person = function(firstName, birthYear){
	// Instance properties
	this.firstName = firstName;
	this.birthYear = birthYear;
	
	//Never add method like that !
	this.firstMethod = func---
}

//An instance of the Person constructor function

const Jack = new Person(Jack, 1998); 


	>>!! Adding methods like that is bad practice !!!
	>> If we initialize 1000 instance of Person -> The 1000 instaces will carry 1000 copyes the method.
	>> Use prototypal inherintance --> See next.
   	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			> USING PROTOTYPES <
			
   > All functions in JAVASCRIPT have a property called prototype (Also constructor functions).
   > Every object created by a constructor function will get acces to all the methods and properties that we define on the 
   constructor protoype property.
   
   	 >>>  SINTAX  <<< 
  //Access the protype property(is an object) of the Person constructor function to add methods.
  
Person.prototype.methodName = function () {code here};

  //Then acces the method normally.
 
Object1.methodName();	

  -> Object1 is an instance of person and has access to "methodName" through protypal inheritance.
  -> It exists just one copy of the function. All instances access to that function.
	
  To see the prototype of an instance:
  	· .__proto__ method --> returns the protype property/ object of the constructor.

!! Important
  · Person.prototype : Is the protoype of the instances created with the Person constructor function, not the prototype
of the Person constructor function.

  · We can also add PROPERTIES to the prototype, and we can access them from the instances, but it won't be in
  the created oject, it will be part of the prototype.
  -> We can check if a property in from the object itself or if it's inherited from the prototype:
  With the method: "hasOwnProperty("propertyName");" 
